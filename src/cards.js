// backend/src/cards.js
import fs from 'fs';
import path from 'path';
import url from 'url';
import Papa from 'papaparse';

const __dirname = path.dirname(url.fileURLToPath(import.meta.url));

export function normalizePromptText(raw = '') {
  try {
    let s = String(raw || '').trim();
    s = s.replace(/^[\s\u2756]+/, '');
    s = s.replace(/^wie\s+(hoch|schwer|groß|lang|weit|alt|breit)\s+(ist\s+(der|die|das)\s+)?/i, '');
    s = s.replace(/^was\s+ist\s+(der|die|das)\s+/i, '');
    s = s.replace(/[\?\!]+$/g, '');
    s = s.replace(/[-–—]{2,}/g, '—');
    s = s.replace(/\s{2,}/g, ' ');
    return s.trim();
  } catch (e) { return raw; }
}

export function loadItemsFromCSV() {
  try {
  // Prefer the latest safe emojified filled CSV if present (generated by tools/safe_fill_from_review.js)
  const improvedFun = path.join(__dirname, '..', 'data', 'Schaetzchen_CONSOLIDATED_for_App_valid_emojified_filled_with_improved_funfacts.csv');
  const preferred = path.join(__dirname, '..', 'data', 'Schaetzchen_CONSOLIDATED_for_App_valid_emojified_filled_safe.csv');
  const fallbackValid = path.join(__dirname, '..', 'data', 'Schaetzchen_CONSOLIDATED_for_App_valid.csv');
  // Prefer improved funfacts (if present), then safe emojified, then valid, then raw
  const csvPath = fs.existsSync(improvedFun) ? improvedFun : (fs.existsSync(preferred) ? preferred : (fs.existsSync(fallbackValid) ? fallbackValid : path.join(__dirname, '..', 'data', 'Schaetzchen_CONSOLIDATED_for_App.csv')));
    const text = fs.readFileSync(csvPath, 'utf8');
    // BOM entfernen
    const rawText = (text && text.charCodeAt(0) === 0xFEFF) ? text.slice(1) : text;
    const firstLine = rawText.split(/\r?\n/)[0] || '';
    const detectDelimiter = (line) => {
      const semi = (line.match(/;/g) || []).length;
      const comm = (line.match(/,/g) || []).length;
      return semi > comm ? ';' : ',';
    };
    const delimiter = detectDelimiter(firstLine);

    const COLMAP = {
      Kategorie: 'category', ID: 'id', Kurzname: 'short_name', Prompt: 'prompt', Typ: 'kind', display_unit: 'display_unit',
      Zielwert: 'display_value', value_si: 'value_si', Emoji: 'emoji', FunFact: 'fun_fact', Difficulty: 'difficulty', Notiz: 'note',
      category: 'category', id: 'id', short_name: 'short_name', prompt: 'prompt', kind: 'kind', display_value: 'display_value',
      value_si: 'value_si', emoji: 'emoji', fun_fact: 'fun_fact', difficulty: 'difficulty', note: 'note'
    };

    const parsed = Papa.parse(rawText, { header: true, skipEmptyLines: true, delimiter });
    if (parsed.errors && parsed.errors.length) console.warn('[cards] CSV parse warnings:', parsed.errors.slice(0,3));
    const rows = (parsed.data || []).map(r => {
      const out = {};
      for (const k of Object.keys(r)) {
        const key = COLMAP[k] || k;
        out[key] = r[k];
      }
      return out;
    });

    const out = { speed: [], distance: [], weight: [], size: [] };
    const mapCategory = (k) => {
      if (!k) return null; const s = String(k).toLowerCase();
      if (s.includes('geschwindigkeit') || s.includes('speed')) return 'speed';
      if (s.includes('entfernung') || s.includes('distance')) return 'distance';
      if (s.includes('größe') || s.includes('gro') || s.includes('size')) return 'size';
      if (s.includes('gewicht') || s.includes('weight')) return 'weight';
      return null;
    };

    for (let i = 0; i < rows.length; i++) {
      const row = rows[i] || {};
      const catRaw = row.category || row.Kategorie || '';
      const cat = mapCategory(catRaw);
  // robust parse of numeric values from CSV
  // - if CSV provides `value_si`, treat that as already in SI (do NOT convert)
  // - otherwise, parse the display value and convert to SI using display_unit when available
  const rawValueSiField = (row.value_si || row.valueSi || row.valueSI || '').toString().trim();
  const rawDisplayField = (row.display_value || row.value || '').toString().trim();
  const display_unit = String(row.display_unit || row.unit || '').trim();

  let valueSI = NaN;
  if (rawValueSiField !== '') {
    // CSV provided an explicit SI value -> parse it directly as SI
    valueSI = parseFloat(rawValueSiField.replace(/[\s\u00A0]/g, '').replace(',', '.'));
  } else {
    // no explicit SI provided: parse the display value and convert if we have a display unit
    const parsedDisplay = parseFloat(rawDisplayField.replace(/[\s\u00A0]/g, '').replace(',', '.'));
    if (isFinite(parsedDisplay) && display_unit) {
      valueSI = toSI({ display_unit }, parsedDisplay, display_unit);
    } else {
      valueSI = parsedDisplay;
    }
  }
  if (!cat || !isFinite(valueSI)) continue;

      const id = row.id || (`r${i}`);
      const prompt = row.prompt || row.short_name || '';
  const displayUnit = row.display_unit || '';
      const funFact = row.fun_fact || row.FunFact || '';
      const emoji = row.emoji || row.Emoji || '';
      const difficulty = (row.difficulty || row.Difficulty || 'medium').toLowerCase();
      const typ = row.kind || row.Typ || '';
      const kurzname = row.short_name || '';
      const notiz = row.note || row.Notiz || '';

      out[cat].push({
        id: String(id),
        prompt: String(prompt),
        kurzname: String(kurzname),
        typ: String(typ),
  display_unit: String(displayUnit),
        zielwert: String(row.display_value || ''),
  value_si: valueSI,
        Emoji: emoji,
        FunFact: funFact,
        Difficulty: difficulty || 'medium',
        Notiz: notiz,
        unit: String(displayUnit || ''),
        trueValue: valueSI,
      });
    }
    // If parsed rows are unexpectedly few, try a fallback to the older normalized CSV
    const totalRows = rows.length || 0;
    if (totalRows < 10) {
      try {
        const fallbackPath = path.join(__dirname, '..', 'data', 'items_full_normalized.csv');
        if (fs.existsSync(fallbackPath)) {
          const rawFallback = fs.readFileSync(fallbackPath, 'utf8');
          const linesFB = rawFallback.split(/\r?\n/).filter(Boolean);
          if (linesFB.length > 1) {
            const safeSplit = (row) => row.split(/,(?=(?:[^"]*"[^"]*")*[^"]*$)/).map(s => s.trim().replace(/^"|"$/g, ''));
            const headerFB = safeSplit(linesFB[0]).map(h => h.trim().toLowerCase());
            const idx = (name) => headerFB.findIndex(h => h === name.toLowerCase());
            const iCat = idx('category');
            const iId = idx('id');
            const iPrompt = idx('prompt');
            const iUnit = idx('unit');
            const iTrue = idx('truevalue') >= 0 ? idx('truevalue') : idx('truevalue');
            const iFun = idx('funfact');
            for (let j = 1; j < linesFB.length; j++) {
              const cols = safeSplit(linesFB[j]);
              const cat = (cols[iCat] || '').toLowerCase();
              if (!cat) continue;
              const id = cols[iId] || `fb${j}`;
              const prompt = cols[iPrompt] || '';
              const unit = cols[iUnit] || '';
              const trueVal = parseFloat(String(cols[iTrue] || '').replace(/[,\s]/g, '.'));
              const fun = cols[iFun] || '';
              if (!isFinite(trueVal)) continue;
              // map category names to our keys
              const mapCat = (c) => {
                if (!c) return null; const s = String(c).toLowerCase();
                if (s.includes('speed')) return 'speed';
                if (s.includes('distance') || s.includes('entfernung')) return 'distance';
                if (s.includes('size') || s.includes('größe') || s.includes('gro')) return 'size';
                if (s.includes('weight') || s.includes('gewicht')) return 'weight';
                return null;
              };
              const catKey = mapCat(cat);
              if (!catKey) continue;
              out[catKey].push({ id: String(id), prompt: String(prompt), display_unit: String(unit), value_si: trueVal, Emoji: '', FunFact: fun, Difficulty: 'medium', unit: String(unit), trueValue: trueVal });
            }
            console.log('[cards] fallback loaded from items_full_normalized.csv, totals:', Object.keys(out).reduce((acc,k)=> (acc[k]=out[k].length,acc),{}));
          }
        }
      } catch (e) {
        console.warn('[cards] fallback load failed:', e && e.message);
      }
    }

    // quick counts log
    const counts = {};
    for (const k of Object.keys(out)) counts[k] = out[k].length;
    console.log('[cards] rows loaded:', rows.length, 'delimiter:', delimiter);
    console.log('[cards] by category:', counts);
    return out;
  } catch (e) {
    console.error('loadItemsFromCSV failed:', e && e.message);
    return {
      speed: [{ id: 's1', prompt: 'Gepard', unit: 'km/h', trueValue: 110 / 3.6, display_unit: 'km/h', value_si: 110 / 3.6, FunFact: 'Schnellstes Landtier' }],
      distance: [{ id: 'd1', prompt: 'Marathon', unit: 'm', trueValue: 42195, display_unit: 'm', value_si: 42195, FunFact: 'Olympische Distanz' }],
      weight: [{ id: 'w1', prompt: 'Kasten Bier', unit: 'kg', trueValue: 18, display_unit: 'kg', value_si: 18, FunFact: '24×0,5l' }],
      size: [{ id: 'z1', prompt: 'Giraffe', unit: 'm', trueValue: 5.5, display_unit: 'm', value_si: 5.5, FunFact: 'Höchstes Landtier' }],
    };
  }
}

export function toSI(card, value, unit) {
  try {
    const display = unit || card?.display_unit || card?.unit || '';
    const v = Number(value);
    if (!isFinite(v)) return NaN;
    const d = String(display || '').toLowerCase();
    // Geschwindigkeit: SI = m/s
    if (d === 'km/h' || d === 'kmh') return v / 3.6;
    if (d === 'm/s' || d === 'ms') return v;
    // Entfernung: SI = m
    if (d === 'km') return v * 1000;
    if (d === 'm') return v;
    // Größe: SI = m
    if (d === 'mm') return v / 1000;
    if (d === 'cm') return v / 100;
    if (d === 'm') return v;
    // Gewicht: SI = kg
    if (d === 'g') return v / 1000;
    if (d === 't') return v * 1000;
    if (d === 'kg') return v;
    return v;
  } catch (e) { return NaN; }
}

function roundForUI(x) {
  const abs = Math.abs(x);
  const isIntish = Math.abs(x - Math.round(x)) < 1e-6;
  if (abs < 10 && !isIntish) return x.toFixed(1);
  return String(Math.round(x));
}

// Auto-switch units for readability: meters >= 1000 -> km, grams >=1000 -> kg, m/s -> km/h optional
export function formatFromSI(card, si, forcedUnit) {
  const u = forcedUnit || card?.display_unit || card?.unit || '';
  const c = String((card && (card.Kategorie || card.category)) || '').toLowerCase();
  const uLower = String(u).toLowerCase();
  try {
    // If a specific unit was requested (forcedUnit or card.display_unit), prefer it.
    // SPEED explicit units
    if (uLower === 'km/h' || uLower === 'kmh') return { value: roundForUI(si * 3.6), unit: 'km/h' };
    if (uLower === 'm/s' || uLower === 'ms') return { value: (Math.abs(si) < 10 && !Number.isInteger(si)) ? si.toFixed(1) : String(Math.round(si)), unit: 'm/s' };

    // DISTANCE explicit units
    if (uLower === 'm') return { value: (Math.abs(si) < 10 && !Number.isInteger(si)) ? si.toFixed(1) : String(Math.round(si)), unit: 'm' };
    if (uLower === 'km') {
      const km = si / 1000;
      return { value: (Math.abs(km) < 10 && !Number.isInteger(km)) ? km.toFixed(1) : String(Math.round(km)), unit: 'km' };
    }

    // SIZE explicit units
    if (uLower.includes('mm')) return { value: roundForUI(si * 1000), unit: 'mm' };
    if (uLower.includes('cm')) return { value: roundForUI(si * 100), unit: 'cm' };
    if (uLower === 'm') return { value: (Math.abs(si) < 10 && !Number.isInteger(si)) ? si.toFixed(1) : String(Math.round(si)), unit: 'm' };

    // WEIGHT explicit units
    if (uLower === 'kg') return { value: (Math.abs(si) < 10 && !Number.isInteger(si)) ? si.toFixed(1) : String(Math.round(si)), unit: 'kg' };
    if (uLower.includes('g') && !uLower.includes('kg')) return { value: roundForUI(si * 1000), unit: 'g' };
    if (uLower.includes('t')) {
      const t = si / 1000;
      return { value: (Math.abs(t) < 10 && !Number.isInteger(t)) ? t.toFixed(1) : String(Math.round(t)), unit: 't' };
    }

    // If no explicit unit preference, fall back to category/magnitude based auto-switching
    // speed: either category mentions speed or unit explicitly km/h or m/s
    if (c.includes('geschwindigkeit') || String(u).toLowerCase().includes('km/h') || String(u).toLowerCase().includes('m/s')) {
      // if display wants km/h show km/h (convert), else m/s
      if (String(u).toLowerCase() === 'km/h' || String(u).toLowerCase() === 'kmh') return { value: roundForUI(si * 3.6), unit: 'km/h' };
      return { value: (Math.abs(si) < 10 && !Number.isInteger(si)) ? si.toFixed(1) : String(Math.round(si)), unit: 'm/s' };
    }

    // distance: category or explicit m/km unit
    if (c.includes('entfernung') || c === 'distance' || String(u).toLowerCase() === 'm' || String(u).toLowerCase() === 'km') {
      // auto switch: meters >= 1000 -> km
      if (si >= 1000) {
        const km = si / 1000;
        return { value: (Math.abs(km) < 10 && !Number.isInteger(km)) ? km.toFixed(1) : String(Math.round(km)), unit: 'km' };
      }
      return { value: (Math.abs(si) < 10 && !Number.isInteger(si)) ? si.toFixed(1) : String(Math.round(si)), unit: 'm' };
    }

    // size: category match or unit indicates length/size (mm/cm/m/km)
    if (c.includes('gr\u00f6\u00dfe') || c === 'size' || uLower.includes('mm') || uLower.includes('cm') || uLower === 'm' || uLower === 'km') {
      // auto switch mm/cm/m based on magnitude
      if (si < 0.01) return { value: roundForUI(si * 1000), unit: 'mm' };
      if (si < 1) return { value: roundForUI(si * 100), unit: 'cm' };
      if (si >= 1000) {
        const km = si / 1000;
        return { value: (Math.abs(km) < 10 && !Number.isInteger(km)) ? km.toFixed(1) : String(Math.round(km)), unit: 'km' };
      }
      return { value: (Math.abs(si) < 10 && !Number.isInteger(si)) ? si.toFixed(1) : String(Math.round(si)), unit: 'm' };
    }

    // weight: category match or unit indicates weight (g/kg/t)
    if (c.includes('gewicht') || c === 'weight') {
      // auto switch g/kg/t
      if (si >= 1000) {
        const t = si / 1000;
        // if very large prefer t
        if (t >= 1) return { value: (Math.abs(t) < 10 && !Number.isInteger(t)) ? t.toFixed(1) : String(Math.round(t)), unit: 't' };
        // else kg
        return { value: (Math.abs(si) < 10 && !Number.isInteger(si)) ? si.toFixed(1) : String(Math.round(si)), unit: 'kg' };
      }
      if (si < 1) return { value: roundForUI(si * 1000), unit: 'g' };
      return { value: (Math.abs(si) < 10 && !Number.isInteger(si)) ? si.toFixed(1) : String(Math.round(si)), unit: 'kg' };
    }

    return { value: String(si), unit: u || '' };
  } catch (e) { return { value: String(si), unit: u || '' }; }
}

export function scoreGuess(card, guessValue, guessUnit) {
  const siTrue = Number(card?.value_si ?? card?.trueValue);
  const siGuess = toSI(card, guessValue, guessUnit);
  const diffAbs = Math.abs(siTrue - siGuess);
  const diffPct = siTrue ? Math.abs(diffAbs / siTrue) : null;
  return { siTrue, siGuess, diffAbs, diffPct };
}

export function dealHand(itemsPool, category, excludeIds = []) {
  const pool = (itemsPool[category] || []).filter(i => !excludeIds.includes(i.id));
  const shuffled = [...pool].sort(() => Math.random() - 0.5);
  return shuffled.slice(0, 4).map((i) => ({
    id: i.id,
    Kategorie: category,
    Kurzname: i.kurzname || i.prompt || '',
    Prompt: i.prompt || '',
    Typ: i.typ || '',
    display_unit: i.display_unit || i.unit || '',
    Zielwert: i.zielwert || '',
    value_si: String(i.value_si ?? i.trueValue ?? ''),
    Emoji: i.Emoji || i.emoji || '',
    FunFact: i.FunFact || i.funFact || '',
    Difficulty: i.Difficulty || (i.difficulty || 'medium'),
    Notiz: i.Notiz || i.notiz || '',
    unit: i.unit || i.display_unit || '',
    trueValue: i.value_si ?? i.trueValue,
  }));
}
